package ddpool

import (
	"context"
	"github.com/fsouza/go-dockerclient"
	"github.com/pkg/errors"
	"path/filepath"
)

const (
	// DefaultHostname is the default hostname used by Docker
	DefaultHostname = "unix:///var/run/docker.sock"
)

// NewDockerInstance creates a new DockerInstance using the given hostname.
// If CertPath and TLSVerify is set then use a TLS connection.
// The Docker engine will be contacted during node creation to ensure a connection can be made.
func NewDockerInstance(Hostname, CertPath string, TLSVerify bool) (*DockerInstance, error) {
	var c *docker.Client
	var err error
	if TLSVerify && CertPath != "" {
		c, err = docker.NewTLSClient(
			Hostname,
			filepath.Join(CertPath, "cert.pem"),
			filepath.Join(CertPath, "key.pem"),
			filepath.Join(CertPath, "ca.pem"),
		)
	} else {
		c, err = docker.NewClient(Hostname)
	}
	if err != nil {
		return nil, errors.Wrapf(err, "Parse host %s", Hostname)
	}

	inf, err := c.Info()
	if err != nil {
		return nil, errors.Wrap(err, "Get node information")
	}
	return &DockerInstance{
		ID:       inf.ID,
		Hostname: Hostname,
		Client:   c,
	}, nil
}

// DockerInstance wraps a Docker client with the node ID and hostname of that node.
type DockerInstance struct {
	*docker.Client

	// ID is the unique ID of the node generated by the Docker engine.
	ID string
	// Hostname is the connection URL to the Docker daemon.
	Hostname string
}

type dockerInstanceKeyType int

// DockerInstanceKey stores a DockerInstance in a context.
var DockerInstanceKey dockerInstanceKeyType = 0

// DockerInstanceFromContext gets a DockerInstance from the given context.
// False is returned if no DockerInstance can be found in the given context.
func DockerInstanceFromContext(ctx context.Context) (*DockerInstance, bool) {
	v := ctx.Value(DockerInstanceKey)
	if v == nil {
		return nil, false
	}
	c, ok := v.(*DockerInstance)
	return c, ok
}
